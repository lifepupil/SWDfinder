# HarmonieEEG_LW
# Copyright (C) 2014 Christian Richard

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/gpl.html>. 

# Author contact info:
# lifepupil@gmail.com

# version 2.0 March 26, 2013
# UPDATES:
# 1. No longer assumes that Harmonie output data (input for this function) is always organized in the same fashion,
#	e.g. that channel order across columns is first RF-RB, then LF-RB and last LB-RB, 
#		that only these three channels (and not the subtraction channels) are present in Harmonie output,
#		that there are no non-EEG data in the Harmonie output. All of these assumptions have been found to
#		not always be followed.
#	2. Added safeguards to make sure that the expected channels are the actual channels being handled by the function,
#		and provided means to easily check whether the correct channels were written to the final .lwr file
#	3. Provided a simple (but not yet optimized) way to specify whether the mouse IDs are contained in the 
#		Harmonie output file name or not.
#	4. Added code to pull sample rate for each column (channel, usually) but not ready to dispense with the sampleHz argument passed 
#		to this function when it's called

# version 1.0, Nov 8, 2012
# this function breaks the Harmonie output text file into however many mouse sessions are embedded within it
# This function to be used on Harmonie data output generated by:
#	1. In Harmonie, choose "patient"
#	2. Right mouse click on desired file and select Properties
# 	3. Copy the mouse IDs and date (mmddyy) listed in the Identification field
# 	4. Make sure checkmark next to Workspaces | All Mice
# 	5. Select Tools | Section Marker
# 	6. Hold down left mouse button anywhere over montage and drag the line that appears to the leftmost point before releasing mouse button (total duration should be 0)
# 	7. Use slider at bottom of window to scroll to the end of the recording, then click anywhere on empty white part of screen
# 	8. Select File | Save Selection As Text... and paste contents of Identification field (step#3) into file name field
# 	9. Finally, to get annotation file, select File | Create Report then choose Event Distribution Workbook Report, then Clear SWD and BIPOLAR, then SAVE.
#	10. Run HarmonieEEG_LW function to start
#	11. Run annotConv to complete the annotation conversion 

setproc HarmonieEEG_LW3 {{&string readPath} {&string writePath} {&num mouseIDsinFileName} {&num maxSessionLength}} {
# readPath = HarmonieReadPath
# writePath = lwrPath
# sampleHz = sampleRate

#	readPath = "C:/Users/lifepupil/LastWave/1Chris/Frankel/exptTest/rawdata/"
#	writePath = "C:/Users/lifepupil/LastWave/1Chris/Frankel/exptTest/lwr/"
#	sampleHz = 200

	sampleRates = {}
	
	electrodes = {'RF' 'RB' 'LF' 'LB'}

	totalSeconds = (maxSessionLength/200)
	hours = (totalSeconds/60/60)
	minutes = (hours-int(hours))*60
	seconds = (minutes-int(minutes))*60

	hours = int(hours)
	minutes = int(minutes)
	seconds = int(seconds)
	
	singleColumn = 0
	# get all S file names
	Sfiles = [file list readPath+'*.txt']
	
	# this file loop
	foreach f 0:Sfiles.size-1 {
		# Raw data files from Harmonie can contain single or multiple mice.
		if (mouseIDsinFileName==1) {
			fNames = {}
			# Next 3 lines of code assume that file name is mouse IDs in file, and that last value before .txt is the date of recording, e.g. 091312,
			# e.g. "29723 29724 29725 29726 091312.txt"
			# The next line pulls the mouseIDs from the raw data file name, e.g. "29723"
			foreach mouse Sfiles[f] {fNames += mouse}
			recDate = fNames[@>]
			recDate[[str substr recDate ".txt"]] := ''
		} else {
			mouseID = Sfiles[f]
			mouseID[[str substr mouseID ".txt"]] := ''
		}
		
		# Open file and put each line into its own element; the "^^" separator is used because it is NOT found in these data files 
		# which permits the file to be read as a single column (as HarmonieFile[0], i.e. HarmonieFile[singleColumn]) with multiple rows (HarmonieFile[singleColumn][row].
		# All we want to do is figure out where the actual column header starts (where "TIME" is the first column)
		HarmonieFile = [listv cread readPath+Sfiles[f] s -S "^^"]
		thisRow = 0
		found = 0
		totalMice = 0


		# this 'x' is to exclude the 'TIME' column from EEG channel signals
		evalStr = ""
		while (found==0) {
			# To find the row with header information in it
			if (HarmonieFile[singleColumn][thisRow][1:4]=='TIME') {
				headerList = {}
				header = HarmonieFile[singleColumn][thisRow]
#				header = header[*list,1:]
				header[[str substr header '"']] := ''
				header[[str substr header ',']] := ''
				header[[str substr header 'REF']] := {'RB'}
				echo $header
				
				firstElectrode = 1
				ff = header[*list,firstElectrode]
				ffsubAddr = [str match ff '[123456789]']
				lastMouseID = ff[ffsubAddr]
				#lastMouseID = header[*list,firstElectrode][[str match header[*list,firstElectrode] '[123456789]']]
				echo lastMouseID = $lastMouseID
				
				labelCount = 0
				channelList = {<-1, -1, -1>}
				foreach columnLabel header {
					clParts = {}
					foreach e 0:3 {
						clParts += [str match columnLabel electrodes[e]]
					}
					if (clParts.size==0) {
						evalStr += " x"
					} else {
						# NB - this method only tested on condition where the identical mouse IDs are in adjacent columns
						thisMouseID = columnLabel[[str match columnLabel '[123456789]']]
						echo thisMouseID= $thisMouseID
						echo
						if (lastMouseID != thisMouseID) {
							echo
							echo lastMouseID = $lastMouseID
							echo thisMouseID = $thisMouseID
							echo $columnLabel
							echo
							channelList += {<-1, -1, -1>}
						}
						columnLabel[[str match columnLabel '[123456789]']] :=''

						whichMouse = thisMouseID[0].tonum
						if (whichMouse>0) {whichMouse-=1}
						echo whichMouse= $whichMouse
						if ([str match columnLabel 'RB'].size==1) {
							if ([str match columnLabel 'RF'].size==1) {
								# stores column of RF-RB for this mouse 
								channelList[whichMouse][0] = labelCount
								headerList += columnLabel
								echo RF $labelCount channelList= $channelList[whichMouse][0] $channelList[whichMouse][1] $channelList[whichMouse][2]
								evalStr += " ?"
							} elseif ([str match columnLabel 'LF'].size==1) {
								# stores column of LF-RB for this mouse 
								channelList[whichMouse][1] = labelCount
								headerList += columnLabel
								echo LF $labelCount channelList= $channelList[whichMouse][0] $channelList[whichMouse][1] $channelList[whichMouse][2]
								evalStr += " ?"
							} elseif ([str match columnLabel 'LB'].size==1) {
								# stores column of LB-RB for this mouse
								channelList[whichMouse][2] = labelCount
								headerList += columnLabel
								echo LB $labelCount channelList= $channelList[whichMouse][0] $channelList[whichMouse][1] $channelList[whichMouse][2]
								evalStr += " ?"
							}
						} else {
							evalStr += " x"
						}
						labelCount += 1
						lastMouseID = thisMouseID
					}
				}
				delete HarmonieFile
				found = 1
			} elseif (HarmonieFile[singleColumn][thisRow][1]=='#') {
				channelInfo = {}
				thisInfo = HarmonieFile[singleColumn][thisRow]
				thisInfo[[str match thisInfo '"']]:=''
				thisInfo[[str match thisInfo ',']]:=' '
				foreach info thisInfo {channelInfo+=info}
				sampleRates += channelInfo[@>-1].tonum
				
				thisRow+=1
			} else {
				thisRow+=1
			}
		}

		sampleRates = sampleRates.tosignal
		
		echo 
		echo $header
		echo $evalStr
		# open this S file
		# the headerList.size var is used to generate the same number of ? for each EEG channel in the raw data file (? is used when mix of strings and floats are in column)
		Scmd = "listv cread readPath+Sfiles[f] "+"$evalStr"+" -f thisRow -S ','"
		echo
		echo Opening $Sfiles[f]
		Sdata = [eval %%$Scmd]
		echo ... opened
		
		foreach mn 0:channelList.size-1 {
			# update size of channel map. N.B. - annotation is typically done only on the first two hours of the session
			sessionDur = Sdata[mn][1:].size
			
			if (sessionDur>maxSessionLength) {
				lengthUsed = maxSessionLength
			} else {
				lengthUsed = sessionDur
			}
			
			echo EEG recording is $sessionDur long ~~  maxSessionLength = $maxSessionLength ~~ using $lengthUsed
			
			channelMap = Zero(6,lengthUsed)
			
			channelMap[0;:] = Sdata[mn*3][1:lengthUsed].tosignal
			Sdata[mn*3][0][[str substr Sdata[mn*3][0] '"']]:=''
			Sdata[mn*3][0][[str substr Sdata[mn*3][0] 'REF']]:={'RB'}
			channelMap.name += "$Sdata[mn*3][0]"+" "
			echo $channelMap.name
			
			channelMap[1;:] = Sdata[mn*3+1][1:lengthUsed].tosignal
			Sdata[mn*3+1][0][[str substr Sdata[mn*3+1][0] '"']]:=''
			Sdata[mn*3+1][0][[str substr Sdata[mn*3+1][0] 'REF']]:={'RB'}
			channelMap.name += "$Sdata[mn*3+1][0]"+" "
			echo $channelMap.name
			
			channelMap[2;:] = Sdata[mn*3+2][1:lengthUsed].tosignal
			Sdata[mn*3+2][0][[str substr Sdata[mn*3+2][0] '"']]:=''
			Sdata[mn*3+2][0][[str substr Sdata[mn*3+2][0] 'REF']]:={'RB'}
			channelMap.name += "$Sdata[mn*3+2][0]"+" "
			echo $channelMap.name
				
			# generate subtraction electrode pairs and put into channel map
			channelMap[3;:] = channelMap[0;:]-channelMap[1;:]
			channelMap.name += "LF-RF "
			echo $channelMap.name
			
			channelMap[4;:] = channelMap[0;:]-channelMap[2;:]
			channelMap.name += "LB-RF "
			echo $channelMap.name
			
			channelMap[5;:] = channelMap[1;:]-channelMap[2;:]
			channelMap.name += "LF-LB"
			echo $channelMap.name
			
			# save channel map as mouseID_date of recording.lwr
			if (mouseIDsinFileName==1) {
				thisName = writePath+fNames[mn]+"_"+recDate+".lwr"
			} else {
				mouseNum = mn+1
				thisName = writePath+mouseID+"_"+"$mouseNum"+".lwr"
			}
			echo Writing $thisName
			iwrite channelMap thisName
			delete channelMap
		}
		
		delete Sdata
	}

#thisRow = 0 ;; found = 0 ;; totalMice = 0 ;; singleColumn =0
#foreach thisRow 0:HarmonieFile[0].size-1 {if (HarmonieFile[singleColumn][thisRow][1:4]=='TIME') {echo $thisRow;;break}}
#foreach columnLabel header {thisMN = columnLabel[[str match columnLabel '[123456789]']][0].tonum;;echo $thisMN;;if (thisMN>totalMice) {totalMice = thisMN};;headerList += columnLabel}	
	
}
